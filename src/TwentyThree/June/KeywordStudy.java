package TwentyThree.June;
public class KeywordStudy {

/**
 @INFO
A. Thread의 sleep은 스태틱으로 선언되어 있는 이유는 다음과 같습니다.
* sleep() 메서드는 현재 실행 중인 스레드를 지정된 시간 동안 정지시키는 역할을 합니다.
* 이 메서드는 현재 실행 중인 스레드에 직접 영향을 주기 때문에,
* sleep() 메서드를 호출하려면 현재 실행 중인 스레드에 대한 참조가 필요합니다.
* 스태틱 메서드로 선언되면 다른 스레드에서도 해당 메서드를 호출할 수 있으며,
* 현재 실행 중인 스레드를 알 필요 없이 직접 호출할 수 있습니다.
* 따라서 sleep() 메서드는 스태틱으로 선언되어 있습니다.

A. 뮤텍스(Mutex), 세마포어(Semaphore), 모니터(Monitor)는 동시성 프로그래밍에서 동기화를 위해 사용되는 개념입니다.

* 뮤텍스는 상호 배제를 위한 동기화 기법으로, 오직 하나의 스레드만이 특정 자원에 접근할 수 있도록 제어합니다.
* 세마포어는 동시에 여러 스레드가 특정 자원에 접근할 수 있는 허용 개수를 지정하는 동기화 기법입니다.
* 모니터는 상호 배제와 조건 변수를 함께 제공하는 개념으로, 객체 단위로 동기화를 수행하며,
* 임계 영역에 진입하기 위해 lock을 얻고 나가기 전에 반드시 unlock을 해야합니다.

A. 웹 프로그래밍에서 Synchronized를 사용하면 안 되는 이유는
* Synchronized는 스레드 간의 동기화를 위한 기능으로,
* 동시에 여러 요청을 처리하는 웹 환경에서는 성능 문제를 야기할 수 있기 때문입니다.
* Synchronized는 임계 영역에 락을 걸어 다른 스레드들의 접근을 막는 동작을 수행하므로,
* 한 스레드가 임계 영역에 진입하면 다른 스레드들은 대기해야 합니다.
* 이로 인해 동시에 여러 요청을 처리하는 웹 서버에서는 동시성이 저하되고,
* 대기하는 스레드가 증가하여 처리량이 감소할 수 있습니다.
* 따라서 웹 프로그래밍에서는 Synchronized 대신 동시성을 보장하는 다른 방식을 사용하는 것이 좋습니다.

A. Fork/Join 프레임워크는
* Java 7에서 도입된 병렬 프로그래밍 모델로,
* 작업을 더 작은 작업 단위로 분할한 뒤에 각각의 작업을 병렬로 실행하고,
* 그 결과를 다시 조합하는 방식으로 동작합니다.

* Fork/Join 프레임워크는 다음과 같은 단계로 동작합니다:

* Fork: 주어진 작업을 더 작은 작업 단위로 분할합니다.
* 이 때, 분할된 작업은 각각 독립적으로 실행될 수 있는 단위여야 합니다.
* Join: 병렬로 실행된 작업들의 결과를 조합하여 최종 결과를 얻습니다.
* Recursive Task 또는 Recursive Action: Fork/Join 프레임워크에서는
* RecursiveTask 또는 RecursiveAction 클래스를 사용하여 작업을 정의합니다.
* RecursiveTask는 결과를 반환하는 작업에 사용되고, RecursiveAction은 결과를 반환하지 않는 작업에 사용됩니다.
* Fork/Join 프레임워크는 작업의 분할과 병합을 재귀적인 방식으로 수행하며,
* 스레드 풀을 사용하여 작업을 병렬로 실행합니다.
* 이를 통해 병렬 처리를 위한 작업의 분할과 조합을 간편하게 구현할 수 있습니다.

A. 분산 시스템 환경에서 적용할 수 있는 락 관리 방법은 다음과 같습니다:
* 중앙 집중식 락 관리: 모든 노드가 락 관리를 위해 중앙 집중적으로 특정 서버에 접근하여 락을 얻고 반환합니다.
* 중앙 서버에서 락을 관리하기 때문에 락의 일관성을 보장할 수 있지만,
* 락 서버에 대한 단일 장애점(single point of failure)이 존재할 수 있습니다.
*
* 분산 락 관리: 분산된 노드 간에 락 관리를 분산하여 처리하는 방식입니다.
* 예를 들어, ZooKeeper와 같은 분산 코디네이션 서비스를 사용하여 노드 간에 락을 조율할 수 있습니다.
* 분산 락 관리는 중앙 집중식 락 관리의 단점을 해결할 수 있지만,
* 네트워크 지연 등의 이유로 성능 저하가 발생할 수 있습니다.
*
* 낙관적 락 관리: 충돌이 발생할 가능성이 적을 때,
* 락을 얻기 전까지는 다른 작업을 진행하며,
* 실제 작업을 수행하기 전에 충돌 여부를 확인하는 방식입니다.
* 충돌이 발생한 경우에는 충돌을 해결하고 작업을 다시 수행합니다.
*
* 비관적 락 관리: 작업을 수행하기 전에 락을 획득하고,
* 작업이 완료될 때까지 락을 유지하는 방식입니다.
* 다른 작업들은 해당 락을 얻기 위해 대기해야 합니다.
* 비관적 락 관리는 충돌이 발생할 가능성이 높은 경우에 적합합니다.
* 락 관리 방법은 분산 시스템의 특성과 성능 요구사항에 따라 선택되어야 하며,
* 상황에 맞는 적절한 방법을 선택해야 합니다.

ArrayList와 LinkedList의 차이는 다음과 같습니다:

내부 구조:
 ArrayList는 내부적으로 배열을 사용하여 요소를 저장하고,
 인덱스를 기반으로 요소에 접근합니다.
 LinkedList는 이중 연결 리스트 구조를 사용하여 요소를 저장하고,
 각 요소는 이전 요소와 다음 요소에 대한 참조를 가지고 있습니다.

데이터의 삽입과 삭제:
 ArrayList는 배열의 크기를 동적으로 조정할 수 있지만,
 요소의 삽입이나 삭제가 중간이나 처음 부분에서 발생할 경우 해당 위치 이후의 요소들을 이동시켜야 합니다.
 LinkedList는 각 요소가 이전 요소와 다음 요소에 대한 참조를 가지고 있기 때문에
 요소의 삽입이나 삭제가 상대적으로 빠르게 이루어질 수 있습니다.

접근 속도:
 ArrayList는 인덱스를 기반으로 요소에 접근하기 때문에 특정 인덱스로의 접근이 빠릅니다.
 LinkedList는 각 요소가 이전 요소와 다음 요소에 대한 참조를 가지고 있기 때문에 처음부터 순차적으로 탐색해야 합니다.
 따라서 특정 인덱스로의 접근이 느릴 수 있습니다.

메모리 사용:
 ArrayList는 요소의 데이터와 함께 추가적으로 배열의 크기도 고려해야 하므로,
 메모리 사용이 상대적으로 큽니다.
 LinkedList는 각 요소가 이전 요소와 다음 요소에 대한 참조만을 가지고 있으므로 메모리 사용이 상대적으로 작습니다.

A. LinkedList를 Queue로 사용할 수 있는 이유는
 LinkedList가 Queue 인터페이스를 구현하고 있기 때문입니다. Queue는 FIFO(First-In-First-Out) 순서로 요소를 저장하고 접근하는 자료구조입니다. LinkedList는 이러한 순서를 지원하기 위해 Queue 인터페이스의 메서드를 구현하고 있으므로, LinkedList를 Queue로 사용할 수 있습니다. 예를 들어, LinkedList의 add() 메서드는 Queue의 offer() 메서드와 동일한 역할을 수행합니다.

 A. Stream을 close하지 않으면 리소스 누수(resource leak)가 발생할 수 있습니다. Stream은 데이터 소스와의 연결을 나타내는데, 이 연결은 내부적으로 사용하는 리소스(예: 파일, 네트워크 연결)에 대한 참조를 가지고 있습니다. Stream을 사용한 후에는 해당 리소스를 명시적으로 해제하기 위해 close() 메서드를 호출하여 스트림을 닫아야 합니다. close() 메서드를 호출하지 않으면 리소스가 해제되지 않고 계속해서 사용되므로, 메모리 누수 등의 문제가 발생할 수 있습니다.

 A. 스트림을 닫기 전에 flush를 호출하는 이유는 스트림에 잔류하는 데이터를 강제로 출력하기 위해서입니다. 일반적으로 스트림은 내부적으로 버퍼를 사용하여 데이터를 모아둔 후에 한 번에 출력하는데, flush를 호출하면 버퍼에 있는 데이터를 모두 출력합니다. flush를 호출하지 않고 스트림을 닫으면 버퍼에 있는 데이터가 출력되지 않을 수 있습니다. 특히 네트워크나 파일 출력과 같이 실시간성이 중요한 경우, flush를 호출하여 버퍼의 내용을 즉시 출력하여 데이터의 누락을 방지할 수 있습니다.

 A. Serializable은 자바의 인터페이스로, 직렬화(Serialization)를 지원하기 위해 사용됩니다. 직렬화란 객체를 일련의 바이트로 변환하여 저장하거나 전송하는 과정을 말합니다. Serializable 인터페이스를 구현한 클래스의 객체는 ObjectOutputStream을 사용하여 직렬화할 수 있고, ObjectInputStream을 사용하여 역직렬화할 수 있습니다. 직렬화된 객체는 파일에 저장하거나 네트워크를 통해 전송할 수 있으며, 다른 환경에서 역직렬화하여 객체를 복원할 수 있습니다.

 A. 웹 프로그래밍에서 클라이언트의 상태를 저장하는 방법은 다양합니다. 몇 가지 일반적인 방법은 다음과 같습니다:

쿠키(Cookie): 클라이언트의 상태 정보를 작은 텍스트 형태로 클라이언트에 저장합니다. 클라이언트가 서버에 요청을 보낼 때마다 해당 쿠키를 함께 전송하여 상태 정보를 유지합니다.

세션(Session): 서버 측에서 클라이언트의 상태 정보를 유지합니다. 클라이언트가 서버에 접속하면 서버는 고유한 세션 식별자를 생성하고, 이 식별자를 쿠키나 URL 매개변수 등을 통해 클라이언트에게 전달합니다. 클라이언트는 이 세션 식별자를 사용하여 서버에 저장된 상태 정보에 접근합니다.

히든 필드(Hidden Field): HTML 폼의 입력 필드 중에서 사용자에게는 보이지 않는 숨겨진 필드를 사용하여 상태 정보를 저장합니다. 이러한 숨겨진 필드는 클라이언트가 서버에 데이터를 전송할 때 함께 전송되며, 서버는 이를 통해 클라이언트의 상태를 인식합니다.

 A. 세션 클러스터링을 구현하는 방법은 여러 가지가 있지만 일반적으로는 다음과 같은 접근 방법을 사용합니다:

공유된 데이터 저장소: 여러 서버 간에 세션 데이터를 공유하기 위해 공유된 데이터 저장소(예: 데이터베이스, 분산 캐시)를 사용합니다. 각 서버는 세션 데이터를 해당 저장소에 저장하고 필요할 때 조회하여 사용합니다.

부하 분산 기술: 세션 클러스터링을 구현하기 위해 부하 분산 장치(예: 로드 밸런서)를 사용하여 클라이언트의 요청을 여러 서버로 분산합니다. 이를 통해 클라이언트는 서버 간에 세션을 공유하는 것처럼 사용할 수 있습니다.

세션 클러스터링을 구현할 때는 세션 데이터의 일관성과 동기화 문제에 주의해야 합니다. 여러 서버가 동시에 세션 데이터를 수정하거나 삭제하는 경우 충돌이 발생할 수 있으므로, 적절한 동기화 메커니즘을 사용하여 데이터의 일관성을 유지해야 합니다. 또한, 세션 클러스터링을 사용할 때는 공유 데이터 저장소의 성능과 확장성에 대한 고려도 필요합니다.

 A. Serializable 인터페이스의 특징은 다음과 같습니다:

객체의 직렬화와 역직렬화를 지원하는 메커니즘을 제공합니다. Serializable 인터페이스를 구현한 클래스의 객체는 ObjectOutputStream을 사용하여 직렬화할 수 있고, ObjectInputStream을 사용하여 역직렬화할 수 있습니다.

직렬화된 객체는 일련의 바이트로 변환되므로, 네트워크를 통해 전송하거나 파일에 저장할 수 있습니다.

Serializable 인터페이스는 마커 인터페이스(marker interface)로 분류됩니다. 즉, 메서드나 필드를 선언하지 않고 단순히 인터페이스를 구현함으로써 해당 클래스의 특정 특성을 나타냅니다.

 A. Serializable을 사용할 때 주의해야 할 점은 다음과 같습니다:

직렬화 가능한 클래스는 모든 필드가 Serializable 인터페이스를 구현하거나 transient 키워드를 사용하여 직렬화에서 제외되어야 합니다. 그렇지 않으면 직렬화 시 예외가 발생할 수 있습니다.

직렬화된 데이터는 보안에 민감할 수 있으므로 중요한 정보를 포함하는 클래스를 직렬화해야 할 경우에는 적절한 보안 조치를 취해야 합니다.

직렬화된 데이터의 형식이 변경되면 역직렬화 시 호환성 문제가 발생할 수 있습니다. 따라서 직렬화된 데이터를 장기적으로 저장하거나 네트워크를 통해 전송할 때는 형식의 호환성을 고려해야 합니다.

직렬화는 자바의 기능 중 하나이며, 객체를 일련의 바이트로 변환하여 저장하거나 전송하는데 사용됩니다. 따라서 직렬화는 주로 객체의 상태를 저장하고 복원하는 데 사용되는 기술입니다.


 A. 바이트 오더(Byte Order)는 컴퓨터 메모리 내에서 다중 바이트 데이터(예: 정수, 부동 소수점 수)를 저장하는 방식을 의미합니다. 주로 두 가지 형태의 바이트 오더가 사용됩니다.

빅 엔디언(Big Endian): 가장 높은 자리수의 바이트부터 순서대로 메모리에 저장하는 방식입니다. 네트워크 상에서 주로 사용되는 표준 형태입니다.

리틀 엔디언(Little Endian): 가장 낮은 자리수의 바이트부터 순서대로 메모리에 저장하는 방식입니다. 주로 x86 아키텍처에서 사용됩니다.

네트워크 오더(Network Order)는 네트워크 통신에서 다중 바이트 데이터를 전송하기 위한 표준 순서를 의미합니다. 네트워크 오더는 빅 엔디언 순서를 사용합니다. 따라서, 데이터를 네트워크로 전송하기 전에 빅 엔디언 형태로 변환하여 보내고, 수신 측에서는 받은 데이터를 사용하는 시스템의 바이트 오더로 변환해야 합니다.

HTTP/2(Hypertext Transfer Protocol version 2)는 기존의 HTTP/1.1 프로토콜을 대체하기 위해 개발된 프로토콜입니다. HTTP/2는 다음과 같은 특징을 가지고 있습니다:

다중화(Multiplexing): 단일 TCP 연결을 통해 여러 개의 요청과 응답을 동시에 처리할 수 있습니다. 이로 인해 요청-응답 순서에 대한 의존성이 줄어들어 성능이 향상됩니다.

헤더 압축(Header Compression): 헤더 필드를 압축하여 대역폭을 절약합니다.

서버 푸시(Server Push): 서버가 클라이언트의 요청에 대해 필요한 리소스를 예측하여 미리 전송할 수 있습니다.

HTTP/3는 QUIC(Quick UDP Internet Connections) 프로토콜을 기반으로 개발된 프로토콜입니다. QUIC는 UDP(User Datagram Protocol)를 사용하며, TCP의 문제점을 해결하기 위해 설계되었습니다. HTTP/3는 HTTP/2에서 발생하는 HOLB(Head-of-Line Blocking) 문제를 해결하고자 합니다. HOLB는 하나의 스트림에서 발생한 지연이 다른 스트림에 영향을 주어 전체 성능을 저하시키는 문제입니다. HTTP/3는 멀티플렉싱과 헤더 압축 등 HTTP/2의 기능을 계승하면서 QUIC의 특징인 연결 성립 및 패킷 손실 시 재전송 등을 통해 HOLB 문제를 해결합니다.

WebRTC(Web Real-Time Communication)는 웹 브라우저와 같은 플랫폼에서 플러그인 없이 실시간 음성, 영상, 데이터를 통신하기 위한 API와 프로토콜 모음입니다. WebRTC는 P2P(peer-to-peer) 방식을 사용하여 브라우저 간에 데이터 스트리밍, 음성 및 영상 통화, 파일 공유 등을 가능하게 합니다.

NullPointerException은 자바에서 발생하는 예외 중 하나로, 참조 변수가 null인 상태에서 해당 변수를 사용하려고 할 때 발생합니다. 이는 프로그래머의 실수로 인해 변수에 null 값을 할당하거나 객체를 초기화하지 않은 경우에 주로 발생합니다. NullPointerException은 처리하기 어려운 이유는 예외가 발생한 지점을 명확하게 찾아내기 어렵고, 예외가 발생한 시점과 실제 오류가 발생한 시점이 다를 수 있기 때문입니다. 이를 방지하기 위해 변수 사용 전에 null 체크를 수행하거나, Optional 등의 방어적인 프로그래밍 기법을 사용하여 예외 상황을 방지할 수 있습니다.

Optional은 자바 8에서 추가된 클래스로, null을 포함할 수 있는 컨테이너 클래스입니다. Optional을 사용하면 값이 존재하지 않을 수 있는 상황에서 null 체크를 간편하게 처리할 수 있습니다. Optional은 값이 존재할 경우 해당 값을 감싸고, 값이 없을 경우에는 null 대신에 Optional.empty()를 반환합니다. 이를 통해 NullPointerException을 방지하고, 코드의 가독성과 안정성을 향상시킬 수 있습니다.

자바 8에서 추가된 주요 기능들은 다음과 같습니다:

람다 표현식(Lambda Expressions): 함수형 프로그래밍을 지원하기 위해 추가되었습니다. 간결하고 유연한 함수형 코드 작성이 가능합니다.

스트림(Stream): 컬렉션 처리를 위한 새로운 추상화 개념입니다. 병렬 처리를 통해 간결하고 효율적인 코드 작성이 가능하며, 데이터를 처리하기 위한 다양한 연산을 제공합니다.

메서드 레퍼런스(Method References): 메서드를 참조하여 람다 표현식을 간결하게 작성할 수 있도록 합니다.

인터페이스의 디폴트 메서드(Default Methods): 인터페이스에 기본적인 구현을 제공하기 위해 추가되었습니다. 기존 인터페이스의 수정 없이 새로운 기능을 추가할 수 있습니다.

Optional 클래스: null을 처리하기 위한 새로운 방법으로 추가되었습니다.

날짜 및 시간 API(Java Time API): 기존의 Date 및 Calendar 클래스의 문제점을 개선한 새로운 날짜 및 시간 API가 도입되었습니다.

함수형 프로그래밍은 프로그래밍 패러다임 중 하나로, 함수의 조합을 통해 소프트웨어를 구성하는 스타일입니다. 함수형 프로그래밍은 상태 변경과 가변 데이터보다는 순수 함수(pure function)와 불변 데이터에 초점을 맞춥니다. 주요 특징은 다음과 같습니다:

일급 함수: 함수를 값으로 취급하고 변수에 할당하거나 다른 함수의 인수로 전달할 수 있습니다.

순수 함수: 함수의 실행 결과가 입력에만 의존하고 외부의 상태를 변경하지 않습니다. 같은 입력에 대해 항상 같은 결과를 반환합니다.

불변성: 데이터의 변경을 허용하지 않고, 새로운 데이터를 생성합니다.

재귀: 반복문 대신 재귀 호출을 통해 작업을 수행합니다.

함수형 프로그래밍은 코드의 가독성, 재사용성, 테스트 용이성 등을 향상시키고, 동시성 및 병렬 처리를 쉽게 구현할 수 있는 장점을 가지고 있습니다.

default 키워드는 인터페이스에 기본 구현을 제공하기 위해 자바 8에서 추가되었습니다. default 메서드를 포함하는 인터페이스는 구현 클래스에서 해당 메서드를 오버라이딩하지 않아도 되며, default 메서드를 사용하여 인터페이스에 새로운 기능을 추가할 수 있습니다.

추상 클래스는 인터페이스와 달리 인스턴스화될 수 있는 클래스입니다. 추상 클래스는 구체적인 상태나 동작을 가지며, 상속을 통해 확장되는 클래스의 베이스로 사용됩니다. 추상 클래스는 다중 상속이 불가능하지만, 인터페이스는 다중 상속을 지원합니다. 추상 클래스는 기본 구현을 가지고 있을 수 있으며, 추상 메서드를 포함할 수도 있습니다. 추상 클래스는 구체적인 클래스의 공통 기능을 추상화하여 재사용성을 높이는 데 사용됩니다. 추상 클래스는 클래스 계층 구조에서 상위 클래스로 사용되며, 구체적인 서브 클래스를 만들기 위한 베이스로 사용될 때 유용합니다.

JAVA 유틸리티 클래스를 사용하는 경우:

자주 사용되는 기능을 제공하는 메서드들로 구성된 클래스입니다.
문자열 처리, 날짜 및 시간 조작, 정규 표현식, 수학 연산, 컬렉션 조작 등 다양한 작업을 수행할 수 있습니다.
대표적인 예로는 java.util 패키지에 있는 Collections, Arrays, Math, StringUtils 등이 있습니다.
JAVA 이너 정적 클래스가 생성되는 원리:

이너 정적 클래스(Static Inner Class)는 외부 클래스의 멤버로서 정의되고, 정적 멤버와 같은 방식으로 사용됩니다.
정적 이너 클래스는 외부 클래스의 인스턴스에 대한 참조를 갖지 않고, 독립적으로 생성됩니다.
외부 클래스의 인스턴스를 생성하지 않고도 정적 이너 클래스를 사용할 수 있습니다.
정적 이너 클래스는 외부 클래스의 private 멤버에도 접근할 수 있습니다.
JAVA ThreadLocal을 사용할 때 주의할 점:

ThreadLocal은 쓰레드별로 독립적인 값을 저장하고 사용하는 기능을 제공합니다.
주의해야 할 점은 ThreadLocal 사용 이후에는 반드시 값을 제거해야 합니다. 그렇지 않으면 메모리 누수가 발생할 수 있습니다.
사용이 끝난 후에는 ThreadLocal의 remove() 메서드를 호출하여 값을 제거해야 합니다.
JAVA SimpleDateFormat 쓰레드 세이프티한가 언세이프티한가? 이유는:

SimpleDateFormat은 쓰레드 세이프하지 않습니다.
SimpleDateFormat은 내부적으로 상태를 가지고 있기 때문에 여러 쓰레드에서 동시에 사용할 경우 문제가 발생할 수 있습니다.
쓰레드 간에 SimpleDateFormat 인스턴스를 공유하지 않고, 각 쓰레드마다 독립적인 인스턴스를 생성하여 사용해야 합니다.
JAVA 6에서 7로 변경되면서 곱하기/나누기 연산보다 비트 연산으로 변경된 이유:

비트 연산은 곱하기/나누기 연산보다 연산 속도가 빠르기 때문에 성능 향상을 위해 변경되었습니다.
비트 연산은 CPU에서 직접 처리되기 때문에 연산 시간이 더 짧고, 자원을 덜 사용합니다.
이를 통해 코드 실행 속도가 향상되며, 효율적인 연산을 수행할 수 있습니다.
JAVA 제네릭은 내부적으로 어떻게 동작하는가:

제네릭은 컴파일 시에 타입 체크를 수행하여 타입 안정성을 보장합니다.
제네릭은 컴파일러가 타입 파라미터를 실제 타입으로 치환하는 작업을 수행합니다.
이렇게 하면 컴파일러는 타입 체크를 할 수 있고, 타입 불일치로 인한 런타임 오류를 방지할 수 있습니다.
제네릭은 컴파일 시에 타입 정보를 지워서 실행 시에는 제네릭 타입이 아닌 일반 타입으로 동작합니다. 이를 타입 소거(Type Erasure)라고 합니다.
Comparable, Bounded, Unbounded을 아는가:

Comparable: 객체의 정렬 기준을 지정하기 위한 인터페이스입니다. compareTo() 메서드를 구현하여 정렬 순서를 결정합니다.
Bounded: 제네릭 타입 매개변수에 상한 경계를 지정하는 기능입니다. 특정 클래스의 서브 클래스만을 타입으로 받도록 제한할 수 있습니다.
Unbounded: 제네릭 타입 매개변수에 상한 경계를 지정하지 않는 기능입니다. 모든 클래스를 타입으로 받을 수 있습니다.
JDK 7부터 추가된 쓰레드 모델은 무엇인가:

JDK 7부터는 Fork/Join 프레임워크가 추가되었습니다.
Fork/Join 프레임워크는 병렬 프로그래밍을 위한 쓰레드 풀 기반의 작업 스케줄링을 제공합니다.
작업을 작은 작업 단위로 쪼개어 병렬로 처리하고, 결과를 합쳐서 최종 결과를 얻는 방식으로 동작합니다.
주로 병렬 처리가 필요한 재귀적인 작업에 사용됩니다.
Async Servlet이란:

Async Servlet은 비동기 방식으로 요청을 처리하는 서블릿입니다.
기존의 동기 방식은 요청을 처리하는 동안 쓰레드를 차지하여 다른 요청을 처리할 수 없었습니다.
비동기 방식은 요청을 받은 후에도 쓰레드를 반환하고, 요청 처리가 완료되면 결과를 반환하는 방식입니다.
비동기 방식을 사용하면 서버의 처리량을 향상시킬 수 있으며, 사용자 경험도 향상될 수 있습니다.

JAVA에서 쓰레드 풀을 사용할 때 쓰레드의 개수를 정할 때 고려해야 하는 점:

시스템의 자원(프로세서, 메모리)의 한계를 고려하여 쓰레드 개수를 설정해야 합니다.
쓰레드 개수가 너무 적으면 병렬 처리의 이점을 활용하지 못하고, 처리 속도가 저하될 수 있습니다.
쓰레드 개수가 너무 많으면 쓰레드 간의 경합으로 인해 성능이 저하될 수 있고, 시스템 리소스를 과도하게 사용할 수 있습니다.
작업의 종류, 작업의 성격, 작업의 예상 처리 시간 등을 고려하여 최적의 쓰레드 개수를 결정해야 합니다.
JAVA에서 컨텍스트 스위치란:

컨텍스트 스위치는 CPU가 실행 중인 프로세스나 쓰레드에서 다른 프로세스나 쓰레드로 제어를 양도하는 과정을 말합니다.
실행 중인 프로세스나 쓰레드의 상태(레지스터 값, 스택, 프로그램 카운터 등)를 저장하고, 새로운 프로세스나 쓰레드의 상태를 복원하여 실행을 이어가는 작업을 수행합니다.
컨텍스트 스위치는 프로세스 간의 공유 리소스 접근, 멀티태스킹, 쓰레드 스케줄링 등에서 발생합니다.
JAVA에서 static이란:

static은 클래스 레벨의 키워드로 사용되며, 클래스의 멤버(변수, 메서드, 초기화 블록)를 정적 멤버로 지정하는데 사용됩니다.
정적 멤버는 클래스의 인스턴스를 생성하지 않고도 직접 접근할 수 있습니다.
정적 변수는 클래스당 하나만 존재하며, 모든 인스턴스에서 공유됩니다.
정적 메서드는 인스턴스 변수에 접근할 수 없고, 클래스에서 직접 호출됩니다.
IEEE-754:

IEEE-754는 부동 소수점 수의 표현 방식과 연산 규칙을 정의하는 표준입니다.
이 표준은 부동 소수점 수를 32비트 또는 64비트로 표현하고, 소수점 위치와 지수를 사용하여 실수 값을 표현합니다.
IEEE-754 표준에 따라 부동 소수점 연산은 근사값으로 수행되며, 오차가 발생할 수 있습니다.
JAVA에서 BigDecimal은 왜 안전한가:

BigDecimal은 정확한 10진수 연산을 위한 클래스로, 부동 소수점 연산에서 발생하는 정확도 문제를 피할 수 있습니다.
부동 소수점 연산은 이진법으로 표현되기 때문에 10진수를 정확히 표현할 수 없는 경우가 있습니다.
BigDecimal은 이진법 대신 10진법을 사용하여 소수점 연산을 수행하므로 정확한 결과를 얻을 수 있습니다.
JAVA에서 if문과 Switch문과의 내부 동작방식에 차이:

if문은 조건식을 평가하여 해당하는 조건 블록을 실행합니다. 조건식은 순차적으로 평가되며, true인 첫 번째 조건 블록만 실행됩니다.
Switch문은 조건식의 결과에 따라 다양한 조건 블록 중 하나를 선택하여 실행합니다. 조건식의 결과와 일치하는 case 문부터 실행하며, 일치하는 case를 찾으면 해당 블록을 실행하고 break문을 만날 때까지 아래의 다른 case 블록을 실행합니다.
JAVA에서 static이 위험한 이유:

static 변수는 모든 인스턴스에서 공유되므로 값의 변경이 모든 인스턴스에 영향을 줄 수 있습니다.
static 메서드는 인스턴스 변수에 직접 접근할 수 없으므로 객체 지향적인 설계와 유연성을 제한할 수 있습니다.
다중 스레드 환경에서 static 변수를 사용할 경우 동기화 문제가 발생할 수 있습니다.
상속 관계에서 static 메서드는 오버라이딩되지 않으므로 예상치 못한 동작을 유발할 수 있습니다.
JAVA에서 공유 변수를 써야하는 경우 동시성의 위험이 있는데, 이를 처리하는 방법:

동시성 문제를 해결하기 위해 동기화(Synchronization)를 사용할 수 있습니다.
synchronized 키워드를 사용하여 임계 영역을 설정하거나, Lock 인터페이스를 사용하여 명시적인 락을 사용할 수 있습니다.
락을 사용하여 여러 쓰레드가 동시에 공유 변수에 접근하는 것을 제어하고, 일관된 동작을 보장할 수 있습니다.
JAVA 반복문(for문) 내에서 매번 새로운 객체(new 객체)를 생성하는 것은 좋지 않습니다.

반복문 내에서 객체를 생성하면 메모리 할당과 해제 작업이 반복적으로 수행되어 성능에 부담을 줄 수 있습니다.
객체의 생성은 비용이 크므로, 반복문 외부에서 미리 객체를 생성하고 반복문 내에서 재사용하는 것이 좋습니다.
JAVA 배열의 초기 크기를 10으로 지정한 후, 20개의 값을 넣고 싶을 때:

배열의 크기는 생성 시에 고정되기 때문에 초기 크기를 10으로 지정한 배열에 20개의 값을 넣으려면 새로운 배열을 생성해야 합니다.
더 큰 크기의 배열을 생성한 후, 기존 배열의 값을 새로운 배열로 복사하는 방법을 사용해야 합니다.
배열의 크기를 동적으로 관리하고 싶다면 ArrayList나 LinkedList와 같은 자료구조를 사용하는 것이 더 효율적입니다.
JAVA 객체를 생성할 때 생성자 메서드보다 정적 팩토리 메서드가 좋은 이유:

정적 팩토리 메서드는 객체 생성에 대한 유연성을 제공하고, 코드를 더 명확하게 만들 수 있습니다.
생성자는 호출 시마다 새로운 객체를 생성하지만, 정적 팩토리 메서드는 객체를 캐싱하거나 풀링하여 중복 객체 생성을 방지할 수 있습니다.
이름을 가질 수 있어 객체 생성의 의도를 더 명확하게 표현할 수 있으며, 가독성이 좋아집니다.
인터페이스를 통해 다른 구현 클래스를 반환할 수 있어 유연성을 높일 수 있습니다.
JAVA 메소드의 파라미터로 전달한 객체를 메소드 내에서 변경하지 못하게 하는 방법:

메소드 내에서 전달된 객체를 변경하지 못하도록 하려면 해당 객체를 변경 불가능한(immutable) 객체로 만들어야 합니다.
변경 불가능한 객체는 내부 상태가 변하지 않으므로, 메소드 내에서 값을 변경할 수 없습니다.
객체를 변경 불가능하게 만들기 위해서는 필드를 private으로 선언하고, setter 메서드를 제공하지 않는 등의 방법을 사용합니다.
     */

}