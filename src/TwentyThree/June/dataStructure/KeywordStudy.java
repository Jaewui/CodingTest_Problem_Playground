package TwentyThree.June.dataStructure;
public class KeywordStudy {

/**
 @INFO
A. Thread의 sleep은 스태틱으로 선언되어 있는 이유는 다음과 같습니다.
* sleep() 메서드는 현재 실행 중인 스레드를 지정된 시간 동안 정지시키는 역할을 합니다.
* 이 메서드는 현재 실행 중인 스레드에 직접 영향을 주기 때문에,
* sleep() 메서드를 호출하려면 현재 실행 중인 스레드에 대한 참조가 필요합니다.
* 스태틱 메서드로 선언되면 다른 스레드에서도 해당 메서드를 호출할 수 있으며,
* 현재 실행 중인 스레드를 알 필요 없이 직접 호출할 수 있습니다.
* 따라서 sleep() 메서드는 스태틱으로 선언되어 있습니다.

A. 뮤텍스(Mutex), 세마포어(Semaphore), 모니터(Monitor)는 동시성 프로그래밍에서 동기화를 위해 사용되는 개념입니다.

* 뮤텍스는 상호 배제를 위한 동기화 기법으로, 오직 하나의 스레드만이 특정 자원에 접근할 수 있도록 제어합니다.
* 세마포어는 동시에 여러 스레드가 특정 자원에 접근할 수 있는 허용 개수를 지정하는 동기화 기법입니다.
* 모니터는 상호 배제와 조건 변수를 함께 제공하는 개념으로, 객체 단위로 동기화를 수행하며,
* 임계 영역에 진입하기 위해 lock을 얻고 나가기 전에 반드시 unlock을 해야합니다.

A. 웹 프로그래밍에서 Synchronized를 사용하면 안 되는 이유는
* Synchronized는 스레드 간의 동기화를 위한 기능으로,
* 동시에 여러 요청을 처리하는 웹 환경에서는 성능 문제를 야기할 수 있기 때문입니다.
* Synchronized는 임계 영역에 락을 걸어 다른 스레드들의 접근을 막는 동작을 수행하므로,
* 한 스레드가 임계 영역에 진입하면 다른 스레드들은 대기해야 합니다.
* 이로 인해 동시에 여러 요청을 처리하는 웹 서버에서는 동시성이 저하되고,
* 대기하는 스레드가 증가하여 처리량이 감소할 수 있습니다.
* 따라서 웹 프로그래밍에서는 Synchronized 대신 동시성을 보장하는 다른 방식을 사용하는 것이 좋습니다.

A. Fork/Join 프레임워크는
* Java 7에서 도입된 병렬 프로그래밍 모델로,
* 작업을 더 작은 작업 단위로 분할한 뒤에 각각의 작업을 병렬로 실행하고,
* 그 결과를 다시 조합하는 방식으로 동작합니다.

* Fork/Join 프레임워크는 다음과 같은 단계로 동작합니다:

* Fork: 주어진 작업을 더 작은 작업 단위로 분할합니다.
* 이 때, 분할된 작업은 각각 독립적으로 실행될 수 있는 단위여야 합니다.
* Join: 병렬로 실행된 작업들의 결과를 조합하여 최종 결과를 얻습니다.
* Recursive Task 또는 Recursive Action: Fork/Join 프레임워크에서는
* RecursiveTask 또는 RecursiveAction 클래스를 사용하여 작업을 정의합니다.
* RecursiveTask는 결과를 반환하는 작업에 사용되고, RecursiveAction은 결과를 반환하지 않는 작업에 사용됩니다.
* Fork/Join 프레임워크는 작업의 분할과 병합을 재귀적인 방식으로 수행하며,
* 스레드 풀을 사용하여 작업을 병렬로 실행합니다.
* 이를 통해 병렬 처리를 위한 작업의 분할과 조합을 간편하게 구현할 수 있습니다.

A. 분산 시스템 환경에서 적용할 수 있는 락 관리 방법은 다음과 같습니다:
 분산 락 서비스:
 분산 락 관리를 위해 외부 분산 락 서비스를 활용할 수 있습니다.
 예를 들어, Apache ZooKeeper, Redis 등의 분산 시스템을 활용하여 락을 관리할 수 있습니다.
 분산 락 서비스는 여러 노드 간에 동기화를 유지하고, 락을 획득 및 해제할 수 있는 기능을 제공합니다.

 데이터베이스 락:
 분산 시스템에서는 공유 데이터베이스를 사용하는 경우가 많습니다.
 데이터베이스의 락 기능을 활용하여 동시성을 제어할 수 있습니다.
 예를 들어, 데이터베이스의 트랜잭션 격리 수준을 설정하거나,
 SELECT FOR UPDATE와 같은 락 관련 SQL 문을 사용하여 동시성 문제를 해결할 수 있습니다.
 /
  #데이터베이스 트랜잭션 격리 수준 설정:

 #SELECT ~ FOR UPDATE:
 --  lock를 획득하기 까지 무한정 기다림
 ex) select * from SY_USER
 where USER_NM ='1111'
 for update nowait;

 /

 비관적 락(Pessimistic Locking):
 데이터베이스 레벨에서 락을 적용하여 동시성 문제를 해결할 수 있습니다.
 비관적 락은 데이터에 대한 접근을 제한하여 동시에 여러 사용자 또는 시스템이 데이터를 변경하지 못하도록 합니다.
 데이터베이스에서 제공하는 락 기능인 SELECT FOR UPDATE 등을 사용하여 락을 설정할 수 있습니다.

 낙관적 락(Optimistic Locking):
 데이터베이스 레벨이 아닌 애플리케이션 레벨에서 락을 관리할 수도 있습니다.
 낙관적 락은 데이터를 변경하기 전에 먼저 충돌을 감지하고, 충돌이 발생하면 처리하는 방식입니다.
 일반적으로 버전 관리 기법을 사용하여 데이터의 버전을 관리하고, 업데이트 시에 버전을 체크하여 충돌을 감지합니다.

 분산 캐시:
 분산 시스템 환경에서는 캐시를 활용하여 락을 관리하는 방법도 있습니다.
 캐시를 사용하여 공통 데이터를 저장하고, 해당 데이터에 접근하는 모든 클라이언트가 캐시를 통해 동시에 접근하도록 합니다.
 분산 캐시 시스템인 Redis, Memcached 등을 사용하여 락을 관리할 수 있습니다.

 =================

 분산시스템설계 고려사항 또는 문제점
 1. 시스템간의 정보 공유 어떻게?
 2. 클러스터에 잇는 서버들의 상태를 체크할 필요
 3. 분산된 서버들간에 동기화를 위한 락 처리

 이러한 문제 해결하는 시스템을 코디네이션 서비스 시스템이라고 함. -> apache Zookeeper가 대표적
 분산시스템 내에 상태정보, 설정정보등을 유지 - 이중화등을 통해 고가용성을 제공해야함(NoSQL - Apache HBase, 대용량 분산 큐 시스템 kafka 대표적인사례)
 https://zookeeper.apache.org/doc/r3.4.6/recipes.html
 큐레이터?

 페일오버(failover) : 실 운용환경(컴퓨터 서버, 시스템, 네트워크 등)에서 이상이 생겼을 때 대체 작동 또는 장애 극복(조치)을 위하여 예비 운용환경으로 자동전환되는 기능이다.
 페일백(failback) : 페일오버에 따라 전환된 운용환경을 장애 발생 전 상태로 되돌리는 처리

 DB 클러스터란?  하나의 데이터베이스를 여러개의 서버로 구축되는 경우, 여러개의 컴퓨터가(서버) 하나처럼 동작하는 컴퓨터들의 집합.
 => 조건 3개
 고가용성 : 한 부분의 문제가 전체 시스템을 정지시켜 버리는 것을 SPOF(Single Point Of Failure) 이를 해결하기 위해 고가용성 클러스터를 사용.
 병렬처리 : 복잡한SQL문, 복제 데이터베이스는 항상 원본 데이터베이스와 같은 데이터를 가지고 있기 때문에 DML(SELECT, INSERT, UPDATE, DELETE)을 고려해서 분산시키면 전체적인 성능향상을 시킬 수 있습니다.
 성능향상 : DB 유저수가 막대해지는 케이스는, Web계 어플리케이션에서 자주 발생한다. 대규모 Web 어플리케이션의 경우 DB의 복사본을 만들어서 그 DB를 사용하게 하는 방법인 참조 처리로 유저수가 많아지는 것을 대비할 수 있다.

 클러스터링 - active -active / active - standby
 클러스터링은 여러 대의 서버가 데이터베이스를 공유하므로 병목현상이 발생해 더 많은 비용이 발생할 수 있다. 특히, Active-Active 방식은 모든 서버가 활성화된 상태이므로 병목 현상이 더 심하게 발생할 수 있다. 이러한 단점을 완화시킬 수 있는 방식이 바로 Active-StandBy 방식이다.
 하지만, 장애가 발생했을 경우 Stand-By 상태에서 Active 상태로 전환하는 시간동안 서비스를 사용할 수 없다는 단점도 존재

 병목 현상 : 전체 시스템의 성능이나 용량이 하나의 구성요소로 인해 제한을 받는 현상.

 리플리케이션의 단점
 하지만 리플리케이션이 마냥 좋기만 한 것은 아니다. 리플리케이션이 이루어진 Slave 데이터베이스는 비동기(Asynchronous) 방식으로 Master 데이터베이스와 동기화 한다. 따라서 두 데이터베이스 간의 데이터 동기화가 보장되지 않아 일관성에 문제가 생길 수 있다. 또한, Master 데이터베이스가 정상 작동하지 않는다면 복구 및 대처가 까다롭다.

 트랜잭션은 ACID(A:atomic-원자성, C:consistency-일관성, I:isolation-격리성, D:durability-지속성) 을 보장해야만한다.

 원자성(Atomicity)
 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다.
 예를 들어, 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 빼 오는 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다.
 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.

 일관성(Consistency)
 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.
 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.

 독립성(Isolation)
 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다.
 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.
 은행 관리자는 이체 작업을 하는 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽을 볼 수 없다.
 공식적으로 고립성은 트랜잭션 실행내역은 연속적이어야 함을 의미한다.

 지속성(Durability)
 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다.
 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다.
 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다.
 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.

 실제로는 ACID 원칙은 종종 지켜지지 않는다. 왜냐하면 ACID 원칙을 strict 하게 지키려면 동시성이 매우 떨어지기 때문이다. 그렇기 때문에 DB 엔진은 ACID 원칙을 희생하여 동시성을 얻을 수 있는 방법을 제공한다. 바로 transaction의 격리 수준(isolation level)이다.

 낙관적 락을 구현하는 LockModType의 종류
 OPTIMISTIC : 트랜잭션 시작 시 버전 점검이 수행되고, 트랜잭션 종료 시에도 버전 점검이 수행된다. 버전이 다르면 트랜잭션이 롤백된다.
 OPTIMISTIC_FORCE_INCREMENT : 낙관적 락을 사용하면서 추가로 버전을 강제로 증가시킨다. 관계를 가진 다른 엔터티가 수정되면 버전이 변경된다.
 READ : OPTIMISTIC과 동일하다.
 WRITE : OPTIMSTIC_FORCE_INCREMENT와 동일하다.
 NONE : 엔터티에 @Version이 적용된 필드가 있으면 낙관적 락을 적용한다.
 비관적 락 구현하는 LockModType의 종류
 PESSIMISTIC_READ : 다른 트랜잭션에서 읽기만 가능
 PESSIMISTIC_WRITE : 다른 트랜잭션에서 읽기도 못하고 쓰기도 못함
 PESSIMISTIC_FORCE_INCREMENT : 다른 트랜잭션에서 읽기도 못하고 쓰기도 못함 + 추가적으로 버저닝을 수행한다.
 비관적 락은 조회한 레코드 자체에 락을 걸기 때문에 성능이 저하될 수 있다.
 성능상 이슈가 발견된다면 낙관적 락을 고려해야 한다.

 트랜잭션 격리 수준(isolation) : 동시에 여러트랜잭션이 실행될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지 결정하는 것

 READ UNCOMMITTED:
 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있다. ( 권장 X, 정합성 문제 )
 Dirty Read가 발생할 수 있다.
 READ COMMITTED:
 커밋된 데이터만 읽을 수 있다.
 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.
 오라클 DBMS에서 표준으로 사용하고 있고 가장 많이 선택된다.
 Lost Update, Write Skew, Read Skew가 발생할 수 있다.
 NON-REPEATABLE READ 발생 : NON-REPEATABLE READ란, 하나의 트랜잭션 내에서 동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 REPEATABLE READ 정합성에 어긋나는 것을 말한다.
 REPETABLE READ:
 MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
 Undo 공간에 백업해두고 실제 레코드 값을 변경한다.
 Undo에 백업된 데이터는 주기적으로 삭제한다.
 Phantom Read가 발생할 수 있다.
 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
 Undo를 사용해서 시점을 보장하지만, 새로 삽입된 레코드는 Undo가 없기 때문
 InnoDB에서는 넥스트 키 락(레코드 락 + 갭 락)을 이용해서 Phantom Read 문제를 해결한다!
 SERIALIZABLE:
 모든 트랜잭션을 순서대로 실행한다.
 한 트랜잭션을 다른 트랜잭션으로부터 완전히 분리하는 격리 수준
 모든 부정합 문제 해결

 부정합 문제
 더티 리드 : 다른 트랜잭션에서 처리한 작업이 완료되지 않았음에도 불구하고 다른 트랜잭션에서 볼 수 있게 되는 현상을 말한다.
 NON-REPEATABLE READ : 하나의 트랜잭션 내에서 동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 REPEATABLE READ 정합성에 어긋나는 것을 말한다.
 PHANTOM READ :  SELECT ... FOR UPDATE 쿼리와 같은 쓰기 잠금을 거는 경우 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상을 말한다.


 낙관락/비관락 같은 JPA의 동시성 제어 메커니즘과 DBMS의 트랜잭션 격리 수준의 차이점
 https://stackoverflow.com/questions/22646226/how-are-locking-mechanisms-pessimistic-optimistic-related-to-database-transact
 트랜잭션 내부에서 일관된 읽기를 구현하기 위해 락 대신 MVCC(Multi Version Concurrency Control)을 사용
 =================


ArrayList와 LinkedList의 차이는 다음과 같습니다:

내부 구조:
 ArrayList는 내부적으로 배열을 사용하여 요소를 저장하고,
 인덱스를 기반으로 요소에 접근합니다.
 LinkedList는 이중 연결 리스트 구조를 사용하여 요소를 저장하고,
 각 요소는 이전 요소와 다음 요소에 대한 참조를 가지고 있습니다.

데이터의 삽입과 삭제:
 ArrayList는 배열의 크기를 동적으로 조정할 수 있지만,
 요소의 삽입이나 삭제가 중간이나 처음 부분에서 발생할 경우 해당 위치 이후의 요소들을 이동시켜야 합니다.
 LinkedList는 각 요소가 이전 요소와 다음 요소에 대한 참조를 가지고 있기 때문에
 요소의 삽입이나 삭제가 상대적으로 빠르게 이루어질 수 있습니다.

접근 속도:
 ArrayList는 인덱스를 기반으로 요소에 접근하기 때문에 특정 인덱스로의 접근이 빠릅니다.
 LinkedList는 각 요소가 이전 요소와 다음 요소에 대한 참조를 가지고 있기 때문에 처음부터 순차적으로 탐색해야 합니다.
 따라서 특정 인덱스로의 접근이 느릴 수 있습니다.

메모리 사용:
 ArrayList는 요소의 데이터와 함께 추가적으로 배열의 크기도 고려해야 하므로,
 메모리 사용이 상대적으로 큽니다.
 LinkedList는 각 요소가 이전 요소와 다음 요소에 대한 참조만을 가지고 있으므로 메모리 사용이 상대적으로 작습니다.

A. LinkedList를 Queue로 사용할 수 있는 이유는
 LinkedList가 Queue 인터페이스를 구현하고 있기 때문입니다.
 Queue는 FIFO(First-In-First-Out) 순서로 요소를 저장하고 접근하는 자료구조입니다.
 LinkedList는 이러한 순서를 지원하기 위해 Queue 인터페이스의 메서드를 구현하고 있으므로,
 LinkedList를 Queue로 사용할 수 있습니다. 예를 들어,
 LinkedList의 add() 메서드는 Queue의 offer() 메서드와 동일한 역할을 수행합니다.

 A. Stream을 close하지 않으면 어던 문제가 발생하나요?
 리소스 누수(resource leak)가 발생할 수 있습니다.
 Stream은 데이터 소스와의 연결을 나타내는데, 이 연결은 내부적으로 사용하는 리소스(예: 파일, 네트워크 연결)에 대한 참조를 가지고 있습니다.
 Stream을 사용한 후에는 해당 리소스를 명시적으로 해제하기 위해 close() 메서드를 호출하여 스트림을 닫아야 합니다.
 close() 메서드를 호출하지 않으면 리소스가 해제되지 않고 계속해서 사용되므로, 메모리 누수 등의 문제가 발생할 수 있습니다.

 A. 스트림을 닫기 전에 flush를 호출하는 이유는 무엇인가요?
 스트림에 잔류하는 데이터를 강제로 출력하기 위해서입니다.
 일반적으로 스트림은 내부적으로 버퍼를 사용하여 데이터를 모아둔 후에 한 번에 출력하는데,
 flush를 호출하면 버퍼에 있는 데이터를 모두 출력합니다.
 flush를 호출하지 않고 스트림을 닫으면 버퍼에 있는 데이터가 출력되지 않을 수 있습니다.
 특히 네트워크나 파일 출력과 같이 실시간성이 중요한 경우,
 flush를 호출하여 버퍼의 내용을 즉시 출력하여 데이터의 누락을 방지할 수 있습니다.

 A. Serializable이란?
 Serializable은 자바의 인터페이스로, 직렬화(Serialization)를 지원하기 위해 사용됩니다.
 직렬화란 객체를 일련의 바이트로 변환하여 저장하거나 전송하는 과정을 말합니다.
 Serializable 인터페이스를 구현한 클래스의 객체는 ObjectOutputStream을 사용하여 직렬화할 수 있고,
 ObjectInputStream을 사용하여 역직렬화할 수 있습니다. 직렬화된 객체는 파일에 저장하거나
 네트워크를 통해 전송할 수 있으며, 다른 환경에서 역직렬화하여 객체를 복원할 수 있습니다.

 A. 웹 프로그래밍에서 클라이언트의 상태를 저장하는 방법은?

 쿠키(Cookie): 클라이언트의 상태 정보를 작은 텍스트 형태로 클라이언트에 저장합니다.
              클라이언트가 서버에 요청을 보낼 때마다 해당 쿠키를 함께 전송하여 상태 정보를 유지합니다.

 세션(Session): 서버 측에서 클라이언트의 상태 정보를 유지합니다.
               클라이언트가 서버에 접속하면 서버는 고유한 세션 식별자를 생성하고,
               이 식별자를 쿠키나 URL 매개변수 등을 통해 클라이언트에게 전달합니다.
               클라이언트는 이 세션 식별자를 사용하여 서버에 저장된 상태 정보에 접근합니다.

 히든 필드(Hidden Field): HTML 폼의 입력 필드 중에서 사용자에게는 보이지 않는 숨겨진 필드를 사용하여 상태 정보를 저장합니다.
                        이러한 숨겨진 필드는 클라이언트가 서버에 데이터를 전송할 때 함께 전송되며,
                        서버는 이를 통해 클라이언트의 상태를 인식합니다.

 A. 세션 클러스터링을 구현하는 방법은 여러 가지가 있지만 일반적으로는 다음과 같은 접근 방법을 사용합니다:

공유된 데이터 저장소: 여러 서버 간에 세션 데이터를 공유하기 위해 공유된 데이터 저장소(예: 데이터베이스, 분산 캐시)를 사용합니다. 각 서버는 세션 데이터를 해당 저장소에 저장하고 필요할 때 조회하여 사용합니다.

부하 분산 기술: 세션 클러스터링을 구현하기 위해 부하 분산 장치(예: 로드 밸런서)를 사용하여 클라이언트의 요청을 여러 서버로 분산합니다. 이를 통해 클라이언트는 서버 간에 세션을 공유하는 것처럼 사용할 수 있습니다.

세션 클러스터링을 구현할 때는 세션 데이터의 일관성과 동기화 문제에 주의해야 합니다. 여러 서버가 동시에 세션 데이터를 수정하거나 삭제하는 경우 충돌이 발생할 수 있으므로, 적절한 동기화 메커니즘을 사용하여 데이터의 일관성을 유지해야 합니다. 또한, 세션 클러스터링을 사용할 때는 공유 데이터 저장소의 성능과 확장성에 대한 고려도 필요합니다.

 A. Serializable 인터페이스의 특징은 다음과 같습니다:

객체의 직렬화와 역직렬화를 지원하는 메커니즘을 제공합니다. Serializable 인터페이스를 구현한 클래스의 객체는 ObjectOutputStream을 사용하여 직렬화할 수 있고, ObjectInputStream을 사용하여 역직렬화할 수 있습니다.

직렬화된 객체는 일련의 바이트로 변환되므로, 네트워크를 통해 전송하거나 파일에 저장할 수 있습니다.

Serializable 인터페이스는 마커 인터페이스(marker interface)로 분류됩니다. 즉, 메서드나 필드를 선언하지 않고 단순히 인터페이스를 구현함으로써 해당 클래스의 특정 특성을 나타냅니다.

 A. Serializable을 사용할 때 주의해야 할 점은 다음과 같습니다:

직렬화 가능한 클래스는 모든 필드가 Serializable 인터페이스를 구현하거나 transient 키워드를 사용하여 직렬화에서 제외되어야 합니다. 그렇지 않으면 직렬화 시 예외가 발생할 수 있습니다.

직렬화된 데이터는 보안에 민감할 수 있으므로 중요한 정보를 포함하는 클래스를 직렬화해야 할 경우에는 적절한 보안 조치를 취해야 합니다.

직렬화된 데이터의 형식이 변경되면 역직렬화 시 호환성 문제가 발생할 수 있습니다. 따라서 직렬화된 데이터를 장기적으로 저장하거나 네트워크를 통해 전송할 때는 형식의 호환성을 고려해야 합니다.

직렬화는 자바의 기능 중 하나이며, 객체를 일련의 바이트로 변환하여 저장하거나 전송하는데 사용됩니다. 따라서 직렬화는 주로 객체의 상태를 저장하고 복원하는 데 사용되는 기술입니다.


 A. 바이트 오더(Byte Order)는 컴퓨터 메모리 내에서 다중 바이트 데이터(예: 정수, 부동 소수점 수)를 저장하는 방식을 의미합니다. 주로 두 가지 형태의 바이트 오더가 사용됩니다.

빅 엔디언(Big Endian): 가장 높은 자리수의 바이트부터 순서대로 메모리에 저장하는 방식입니다. 네트워크 상에서 주로 사용되는 표준 형태입니다.

리틀 엔디언(Little Endian): 가장 낮은 자리수의 바이트부터 순서대로 메모리에 저장하는 방식입니다. 주로 x86 아키텍처에서 사용됩니다.

네트워크 오더(Network Order)는 네트워크 통신에서 다중 바이트 데이터를 전송하기 위한 표준 순서를 의미합니다. 네트워크 오더는 빅 엔디언 순서를 사용합니다. 따라서, 데이터를 네트워크로 전송하기 전에 빅 엔디언 형태로 변환하여 보내고, 수신 측에서는 받은 데이터를 사용하는 시스템의 바이트 오더로 변환해야 합니다.

HTTP/2(Hypertext Transfer Protocol version 2)는 기존의 HTTP/1.1 프로토콜을 대체하기 위해 개발된 프로토콜입니다. HTTP/2는 다음과 같은 특징을 가지고 있습니다:

다중화(Multiplexing): 단일 TCP 연결을 통해 여러 개의 요청과 응답을 동시에 처리할 수 있습니다. 이로 인해 요청-응답 순서에 대한 의존성이 줄어들어 성능이 향상됩니다.

헤더 압축(Header Compression): 헤더 필드를 압축하여 대역폭을 절약합니다.

서버 푸시(Server Push): 서버가 클라이언트의 요청에 대해 필요한 리소스를 예측하여 미리 전송할 수 있습니다.

HTTP/3는 QUIC(Quick UDP Internet Connections) 프로토콜을 기반으로 개발된 프로토콜입니다. QUIC는 UDP(User Datagram Protocol)를 사용하며, TCP의 문제점을 해결하기 위해 설계되었습니다. HTTP/3는 HTTP/2에서 발생하는 HOLB(Head-of-Line Blocking) 문제를 해결하고자 합니다. HOLB는 하나의 스트림에서 발생한 지연이 다른 스트림에 영향을 주어 전체 성능을 저하시키는 문제입니다. HTTP/3는 멀티플렉싱과 헤더 압축 등 HTTP/2의 기능을 계승하면서 QUIC의 특징인 연결 성립 및 패킷 손실 시 재전송 등을 통해 HOLB 문제를 해결합니다.

WebRTC(Web Real-Time Communication)는 웹 브라우저와 같은 플랫폼에서 플러그인 없이 실시간 음성, 영상, 데이터를 통신하기 위한 API와 프로토콜 모음입니다. WebRTC는 P2P(peer-to-peer) 방식을 사용하여 브라우저 간에 데이터 스트리밍, 음성 및 영상 통화, 파일 공유 등을 가능하게 합니다.

NullPointerException은 자바에서 발생하는 예외 중 하나로, 참조 변수가 null인 상태에서 해당 변수를 사용하려고 할 때 발생합니다. 이는 프로그래머의 실수로 인해 변수에 null 값을 할당하거나 객체를 초기화하지 않은 경우에 주로 발생합니다. NullPointerException은 처리하기 어려운 이유는 예외가 발생한 지점을 명확하게 찾아내기 어렵고, 예외가 발생한 시점과 실제 오류가 발생한 시점이 다를 수 있기 때문입니다. 이를 방지하기 위해 변수 사용 전에 null 체크를 수행하거나, Optional 등의 방어적인 프로그래밍 기법을 사용하여 예외 상황을 방지할 수 있습니다.

Optional은 자바 8에서 추가된 클래스로, null을 포함할 수 있는 컨테이너 클래스입니다. Optional을 사용하면 값이 존재하지 않을 수 있는 상황에서 null 체크를 간편하게 처리할 수 있습니다. Optional은 값이 존재할 경우 해당 값을 감싸고, 값이 없을 경우에는 null 대신에 Optional.empty()를 반환합니다. 이를 통해 NullPointerException을 방지하고, 코드의 가독성과 안정성을 향상시킬 수 있습니다.

자바 8에서 추가된 주요 기능들은 다음과 같습니다:

람다 표현식(Lambda Expressions): 함수형 프로그래밍을 지원하기 위해 추가되었습니다. 간결하고 유연한 함수형 코드 작성이 가능합니다.

스트림(Stream): 컬렉션 처리를 위한 새로운 추상화 개념입니다. 병렬 처리를 통해 간결하고 효율적인 코드 작성이 가능하며, 데이터를 처리하기 위한 다양한 연산을 제공합니다.

메서드 레퍼런스(Method References): 메서드를 참조하여 람다 표현식을 간결하게 작성할 수 있도록 합니다.

인터페이스의 디폴트 메서드(Default Methods): 인터페이스에 기본적인 구현을 제공하기 위해 추가되었습니다. 기존 인터페이스의 수정 없이 새로운 기능을 추가할 수 있습니다.

Optional 클래스: null을 처리하기 위한 새로운 방법으로 추가되었습니다.

날짜 및 시간 API(Java Time API): 기존의 Date 및 Calendar 클래스의 문제점을 개선한 새로운 날짜 및 시간 API가 도입되었습니다.

함수형 프로그래밍은 프로그래밍 패러다임 중 하나로, 함수의 조합을 통해 소프트웨어를 구성하는 스타일입니다. 함수형 프로그래밍은 상태 변경과 가변 데이터보다는 순수 함수(pure function)와 불변 데이터에 초점을 맞춥니다. 주요 특징은 다음과 같습니다:

일급 함수: 함수를 값으로 취급하고 변수에 할당하거나 다른 함수의 인수로 전달할 수 있습니다.

순수 함수: 함수의 실행 결과가 입력에만 의존하고 외부의 상태를 변경하지 않습니다. 같은 입력에 대해 항상 같은 결과를 반환합니다.

불변성: 데이터의 변경을 허용하지 않고, 새로운 데이터를 생성합니다.

재귀: 반복문 대신 재귀 호출을 통해 작업을 수행합니다.

함수형 프로그래밍은 코드의 가독성, 재사용성, 테스트 용이성 등을 향상시키고, 동시성 및 병렬 처리를 쉽게 구현할 수 있는 장점을 가지고 있습니다.

default 키워드는 인터페이스에 기본 구현을 제공하기 위해 자바 8에서 추가되었습니다. default 메서드를 포함하는 인터페이스는 구현 클래스에서 해당 메서드를 오버라이딩하지 않아도 되며, default 메서드를 사용하여 인터페이스에 새로운 기능을 추가할 수 있습니다.

추상 클래스는 인터페이스와 달리 인스턴스화될 수 있는 클래스입니다. 추상 클래스는 구체적인 상태나 동작을 가지며, 상속을 통해 확장되는 클래스의 베이스로 사용됩니다. 추상 클래스는 다중 상속이 불가능하지만, 인터페이스는 다중 상속을 지원합니다. 추상 클래스는 기본 구현을 가지고 있을 수 있으며, 추상 메서드를 포함할 수도 있습니다. 추상 클래스는 구체적인 클래스의 공통 기능을 추상화하여 재사용성을 높이는 데 사용됩니다. 추상 클래스는 클래스 계층 구조에서 상위 클래스로 사용되며, 구체적인 서브 클래스를 만들기 위한 베이스로 사용될 때 유용합니다.

JAVA 유틸리티 클래스를 사용하는 경우:

자주 사용되는 기능을 제공하는 메서드들로 구성된 클래스입니다.
문자열 처리, 날짜 및 시간 조작, 정규 표현식, 수학 연산, 컬렉션 조작 등 다양한 작업을 수행할 수 있습니다.
대표적인 예로는 java.util 패키지에 있는 Collections, Arrays, Math, StringUtils 등이 있습니다.
JAVA 이너 정적 클래스가 생성되는 원리:

이너 정적 클래스(Static Inner Class)는 외부 클래스의 멤버로서 정의되고, 정적 멤버와 같은 방식으로 사용됩니다.
정적 이너 클래스는 외부 클래스의 인스턴스에 대한 참조를 갖지 않고, 독립적으로 생성됩니다.
외부 클래스의 인스턴스를 생성하지 않고도 정적 이너 클래스를 사용할 수 있습니다.
정적 이너 클래스는 외부 클래스의 private 멤버에도 접근할 수 있습니다.
JAVA ThreadLocal을 사용할 때 주의할 점:

ThreadLocal은 쓰레드별로 독립적인 값을 저장하고 사용하는 기능을 제공합니다.
주의해야 할 점은 ThreadLocal 사용 이후에는 반드시 값을 제거해야 합니다. 그렇지 않으면 메모리 누수가 발생할 수 있습니다.
사용이 끝난 후에는 ThreadLocal의 remove() 메서드를 호출하여 값을 제거해야 합니다.
JAVA SimpleDateFormat 쓰레드 세이프티한가 언세이프티한가? 이유는:

SimpleDateFormat은 쓰레드 세이프하지 않습니다.
SimpleDateFormat은 내부적으로 상태를 가지고 있기 때문에 여러 쓰레드에서 동시에 사용할 경우 문제가 발생할 수 있습니다.
쓰레드 간에 SimpleDateFormat 인스턴스를 공유하지 않고, 각 쓰레드마다 독립적인 인스턴스를 생성하여 사용해야 합니다.
JAVA 6에서 7로 변경되면서 곱하기/나누기 연산보다 비트 연산으로 변경된 이유:

비트 연산은 곱하기/나누기 연산보다 연산 속도가 빠르기 때문에 성능 향상을 위해 변경되었습니다.
비트 연산은 CPU에서 직접 처리되기 때문에 연산 시간이 더 짧고, 자원을 덜 사용합니다.
이를 통해 코드 실행 속도가 향상되며, 효율적인 연산을 수행할 수 있습니다.
JAVA 제네릭은 내부적으로 어떻게 동작하는가:

제네릭은 컴파일 시에 타입 체크를 수행하여 타입 안정성을 보장합니다.
제네릭은 컴파일러가 타입 파라미터를 실제 타입으로 치환하는 작업을 수행합니다.
이렇게 하면 컴파일러는 타입 체크를 할 수 있고, 타입 불일치로 인한 런타임 오류를 방지할 수 있습니다.
제네릭은 컴파일 시에 타입 정보를 지워서 실행 시에는 제네릭 타입이 아닌 일반 타입으로 동작합니다. 이를 타입 소거(Type Erasure)라고 합니다.
Comparable, Bounded, Unbounded을 아는가:

Comparable: 객체의 정렬 기준을 지정하기 위한 인터페이스입니다. compareTo() 메서드를 구현하여 정렬 순서를 결정합니다.
Bounded: 제네릭 타입 매개변수에 상한 경계를 지정하는 기능입니다. 특정 클래스의 서브 클래스만을 타입으로 받도록 제한할 수 있습니다.
Unbounded: 제네릭 타입 매개변수에 상한 경계를 지정하지 않는 기능입니다. 모든 클래스를 타입으로 받을 수 있습니다.
JDK 7부터 추가된 쓰레드 모델은 무엇인가:

JDK 7부터는 Fork/Join 프레임워크가 추가되었습니다.
Fork/Join 프레임워크는 병렬 프로그래밍을 위한 쓰레드 풀 기반의 작업 스케줄링을 제공합니다.
작업을 작은 작업 단위로 쪼개어 병렬로 처리하고, 결과를 합쳐서 최종 결과를 얻는 방식으로 동작합니다.
주로 병렬 처리가 필요한 재귀적인 작업에 사용됩니다.
Async Servlet이란:

Async Servlet은 비동기 방식으로 요청을 처리하는 서블릿입니다.
기존의 동기 방식은 요청을 처리하는 동안 쓰레드를 차지하여 다른 요청을 처리할 수 없었습니다.
비동기 방식은 요청을 받은 후에도 쓰레드를 반환하고, 요청 처리가 완료되면 결과를 반환하는 방식입니다.
비동기 방식을 사용하면 서버의 처리량을 향상시킬 수 있으며, 사용자 경험도 향상될 수 있습니다.

JAVA에서 쓰레드 풀을 사용할 때 쓰레드의 개수를 정할 때 고려해야 하는 점:

시스템의 자원(프로세서, 메모리)의 한계를 고려하여 쓰레드 개수를 설정해야 합니다.
쓰레드 개수가 너무 적으면 병렬 처리의 이점을 활용하지 못하고, 처리 속도가 저하될 수 있습니다.
쓰레드 개수가 너무 많으면 쓰레드 간의 경합으로 인해 성능이 저하될 수 있고, 시스템 리소스를 과도하게 사용할 수 있습니다.
작업의 종류, 작업의 성격, 작업의 예상 처리 시간 등을 고려하여 최적의 쓰레드 개수를 결정해야 합니다.
JAVA에서 컨텍스트 스위치란:

컨텍스트 스위치는 CPU가 실행 중인 프로세스나 쓰레드에서 다른 프로세스나 쓰레드로 제어를 양도하는 과정을 말합니다.
실행 중인 프로세스나 쓰레드의 상태(레지스터 값, 스택, 프로그램 카운터 등)를 저장하고, 새로운 프로세스나 쓰레드의 상태를 복원하여 실행을 이어가는 작업을 수행합니다.
컨텍스트 스위치는 프로세스 간의 공유 리소스 접근, 멀티태스킹, 쓰레드 스케줄링 등에서 발생합니다.
JAVA에서 static이란:

static은 클래스 레벨의 키워드로 사용되며, 클래스의 멤버(변수, 메서드, 초기화 블록)를 정적 멤버로 지정하는데 사용됩니다.
정적 멤버는 클래스의 인스턴스를 생성하지 않고도 직접 접근할 수 있습니다.
정적 변수는 클래스당 하나만 존재하며, 모든 인스턴스에서 공유됩니다.
정적 메서드는 인스턴스 변수에 접근할 수 없고, 클래스에서 직접 호출됩니다.
IEEE-754:

IEEE-754는 부동 소수점 수의 표현 방식과 연산 규칙을 정의하는 표준입니다.
이 표준은 부동 소수점 수를 32비트 또는 64비트로 표현하고, 소수점 위치와 지수를 사용하여 실수 값을 표현합니다.
IEEE-754 표준에 따라 부동 소수점 연산은 근사값으로 수행되며, 오차가 발생할 수 있습니다.
JAVA에서 BigDecimal은 왜 안전한가:

BigDecimal은 정확한 10진수 연산을 위한 클래스로, 부동 소수점 연산에서 발생하는 정확도 문제를 피할 수 있습니다.
부동 소수점 연산은 이진법으로 표현되기 때문에 10진수를 정확히 표현할 수 없는 경우가 있습니다.
BigDecimal은 이진법 대신 10진법을 사용하여 소수점 연산을 수행하므로 정확한 결과를 얻을 수 있습니다.
JAVA에서 if문과 Switch문과의 내부 동작방식에 차이:

if문은 조건식을 평가하여 해당하는 조건 블록을 실행합니다. 조건식은 순차적으로 평가되며, true인 첫 번째 조건 블록만 실행됩니다.
Switch문은 조건식의 결과에 따라 다양한 조건 블록 중 하나를 선택하여 실행합니다. 조건식의 결과와 일치하는 case 문부터 실행하며, 일치하는 case를 찾으면 해당 블록을 실행하고 break문을 만날 때까지 아래의 다른 case 블록을 실행합니다.
JAVA에서 static이 위험한 이유:

static 변수는 모든 인스턴스에서 공유되므로 값의 변경이 모든 인스턴스에 영향을 줄 수 있습니다.
static 메서드는 인스턴스 변수에 직접 접근할 수 없으므로 객체 지향적인 설계와 유연성을 제한할 수 있습니다.
다중 스레드 환경에서 static 변수를 사용할 경우 동기화 문제가 발생할 수 있습니다.
상속 관계에서 static 메서드는 오버라이딩되지 않으므로 예상치 못한 동작을 유발할 수 있습니다.
JAVA에서 공유 변수를 써야하는 경우 동시성의 위험이 있는데, 이를 처리하는 방법:

동시성 문제를 해결하기 위해 동기화(Synchronization)를 사용할 수 있습니다.
synchronized 키워드를 사용하여 임계 영역을 설정하거나, Lock 인터페이스를 사용하여 명시적인 락을 사용할 수 있습니다.
락을 사용하여 여러 쓰레드가 동시에 공유 변수에 접근하는 것을 제어하고, 일관된 동작을 보장할 수 있습니다.
JAVA 반복문(for문) 내에서 매번 새로운 객체(new 객체)를 생성하는 것은 좋지 않습니다.

반복문 내에서 객체를 생성하면 메모리 할당과 해제 작업이 반복적으로 수행되어 성능에 부담을 줄 수 있습니다.
객체의 생성은 비용이 크므로, 반복문 외부에서 미리 객체를 생성하고 반복문 내에서 재사용하는 것이 좋습니다.
JAVA 배열의 초기 크기를 10으로 지정한 후, 20개의 값을 넣고 싶을 때:

배열의 크기는 생성 시에 고정되기 때문에 초기 크기를 10으로 지정한 배열에 20개의 값을 넣으려면 새로운 배열을 생성해야 합니다.
더 큰 크기의 배열을 생성한 후, 기존 배열의 값을 새로운 배열로 복사하는 방법을 사용해야 합니다.
배열의 크기를 동적으로 관리하고 싶다면 ArrayList나 LinkedList와 같은 자료구조를 사용하는 것이 더 효율적입니다.
JAVA 객체를 생성할 때 생성자 메서드보다 정적 팩토리 메서드가 좋은 이유:

정적 팩토리 메서드는 객체 생성에 대한 유연성을 제공하고, 코드를 더 명확하게 만들 수 있습니다.
생성자는 호출 시마다 새로운 객체를 생성하지만, 정적 팩토리 메서드는 객체를 캐싱하거나 풀링하여 중복 객체 생성을 방지할 수 있습니다.
이름을 가질 수 있어 객체 생성의 의도를 더 명확하게 표현할 수 있으며, 가독성이 좋아집니다.
인터페이스를 통해 다른 구현 클래스를 반환할 수 있어 유연성을 높일 수 있습니다.
JAVA 메소드의 파라미터로 전달한 객체를 메소드 내에서 변경하지 못하게 하는 방법:

메소드 내에서 전달된 객체를 변경하지 못하도록 하려면 해당 객체를 변경 불가능한(immutable) 객체로 만들어야 합니다.
변경 불가능한 객체는 내부 상태가 변하지 않으므로, 메소드 내에서 값을 변경할 수 없습니다.
객체를 변경 불가능하게 만들기 위해서는 필드를 private으로 선언하고, setter 메서드를 제공하지 않는 등의 방법을 사용합니다.
     */

}